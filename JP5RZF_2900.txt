%option noyywrap c++ yylineno

%{
#include "Parserbase.h"
%}

DIGIT       [0-9]
WS	    [ \t\n]
BETU        [a-zA-Z]

%%

END         return Parser::END;
LET         return Parser::LET;
IF          return Parser::IF;
THEN        return Parser::THEN;
ELSE        return Parser::ELSE;
ENDIF       return Parser::ENDIF;
WHILE       return Parser::WHILE;
WEND        return Parser::WEND;
INPUT       return Parser::INPUT;
PRINT       return Parser::PRINT;
"="         return Parser::EQUAL;
"<"         return Parser::LT;
">"         return Parser::GT;
"<="        return Parser::LE;
">="        return Parser::GE;
"+"         return Parser::PLUS;
"-"         return Parser::MINUS;
"*"         return Parser::MULTI;
AND         return Parser::AND;
OR          return Parser::OR;
NOT         return Parser::NOT;
"\\"        return Parser::DIV;
MOD         return Parser::MOD;
"("         return Parser::OPEN;
")"         return Parser::CLOSE;

0|[1-9][0-9]* return Parser::NUMBER;

{BETU}({BETU}|{DIGIT})*"&"    return Parser::AZON;

REM.*\n     // megjegyzes: nem kell semmit csinalni

{WS}+       // feher szokozok: semmi teendo

.           {
                std::cerr << lineno() << ": Lexikalis hiba." << std::endl;
                exit(1);
            }

%%

###

%baseclass-preinclude <iostream>
%lsp-needed


%token END
%token LET

%token IF
%token THEN
%token ELSE
%token ENDIF

%token WHILE
%token WEND

%token INPUT
%token PRINT

%token NUMBER

%token OPEN
%token CLOSE

%token AZON

%left NOT
%left OR
%left AND
%left EQUAL
%left GT LT LE GE
%left PLUS MINUS
%left MULTI DIV MOD

%%

start:
    expressions
    {
        std::cout << "start -> expressions" << std::endl;
    }
;

expressions:
    // ures
    {
        std::cout << "expressions -> epszilon" << std::endl;
    }
|
    exp expressions
    {
        std::cout << "expressions -> exp expressions" << std::endl;
    }
|
	END
	{
		std::cout << "expressions -> END" << std::endl;
	}
;

exp:
	egesz
	{
		std::cout << "exp -> egesz" << std::endl;
	}
|
	logical
	{
		std::cout << "exp -> logical" << std::endl;
	}
|
	loop
	{
		std::cout << "exp -> loop" << std::endl;
	}
|
	elag
	{	
		std::cout << "exp -> elag" << std::endl;
	}
|
	io
	{
		std::cout << "exp -> io" << std::endl;	
	}
|
	erta
	{
		std::cout << "exp -> erta" << std::endl;	
	}
;

loop:
	WHILE logical exp WEND
	{
		std::cout << "exp -> elag" << std::endl;
	}
;

elag:
	IF logical THEN exp ENDIF
	{
		std::cout << "elag -> IF logical THEN exp ENDIF" << std::endl;
	}
|
	IF logical THEN exp ELSE exp ENDIF
	{
		std::cout << "elag -> IF logical THEN exp ELSE exp ENDIF" << std::endl;
	}
;

erta:
	LET valt EQUAL egesz
	{
		std::cout << "erta -> LET valt EQ egesz" << std::endl;
	}
;

valt:
	NUMBER
	{
		std::cout << "valt -> NUMBER" << std::endl;
	}
|
	AZON
	{
		std::cout << "valt -> AZON" << std::endl;
	}
;

logical:
	OPEN logical CLOSE
	{
		std::cout << "logical -> OPEN logical CLOSE" << std::endl;
	}
|
	egesz EQUAL egesz
	{
		std::cout << "logical -> egesz EQUAL egesz" << std::endl;
	}
|
	egesz LT egesz
	{
		std::cout << "logical -> egesz LT egesz" << std::endl;
	}
|
	egesz GT egesz
	{
		std::cout << "logical -> egesz GT egesz" << std::endl;
	}
|
	egesz LE egesz
	{
		std::cout << "logical -> egesz LE egesz" << std::endl;
	}
|
	egesz GE egesz
	{
		std::cout << "logical -> egesz GE egesz" << std::endl;
	}
|
	logical AND logical
	{
		std::cout << "logical -> logical AND logical" << std::endl;
	}
|
	logical OR logical
	{
		std::cout << "logical -> logical OR logical" << std::endl;
	}
|
	logical NOT logical
	{
		std::cout << "logical -> logical NOT logical" << std::endl;
	}
;

egesz:
	OPEN egesz CLOSE
	{
		std::cout << "egesz -> OPEN egesz CLOSE" << std::endl;
	}
|
    valt
    {
        std::cout << "egesz -> valt" << std::endl;
    }
|
	valt PLUS valt
	{
		std::cout << "egesz -> valt PLUS valt" << std::endl;
	}
|
	valt MINUS valt
	{
		std::cout << "egesz -> valt MINUS valt" << std::endl;
	}
|
	valt MULTI valt
	{
		std::cout << "egesz -> valt MULTI valt" << std::endl;
	}
|
	valt DIV valt
	{
		std::cout << "egesz -> valt DIV valt" << std::endl;
	}
|
	valt MOD valt
	{
		std::cout << "egesz -> valt MOD valt" << std::endl;
	}
;

io:
	PRINT AZON
	{
		std::cout << "io -> PRINT AZON" << std::endl;
	}
|
	INPUT AZON
	{
		std::cout << "io -> INPUT AZON" << std::endl;
	}
;

###

// Generated by Bisonc++ V4.09.02 on Wed, 28 Oct 2015 08:24:48 +0100

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
#include "FlexLexer.h"
#include <cstdlib>

#undef Parser
class Parser: public ParserBase
{
        
    public:
		Parser( std::istream & in ) : lexer( &in, &std::cerr ) {}
        int parse();

    private:
        yyFlexLexer lexer;
        void error(char const *msg);    // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
        void exceptionHandler__(std::exception const &exc);
};


#endif

###

// Generated by Bisonc++ V4.09.02 on Wed, 28 Oct 2015 08:24:48 +0100

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"


inline void Parser::error(char const *msg)
{
    std::cerr << d_loc__.first_line << ".: Szintaktikus hiba." << std::endl; 
    exit(1);
}

// $insert lex
inline int Parser::lex()
{
    d_loc__.first_line = lexer.lineno();
    return lexer.yylex();
}

inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::exceptionHandler__(std::exception const &exc)         
{
    throw;              // re-implement to handle exceptions thrown by actions
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

//using namespace std;

###

#include <iostream>
#include <fstream>
#include <string>
#include "Parser.h"
#include <FlexLexer.h>

using namespace std;

void input_handler( ifstream& in, int argc, char* argv[] );

int main( int argc, char* argv[] )
{
    ifstream in;
    input_handler( in, argc, argv );
    Parser pars( in );
    pars.parse();
    return 0;
}

void input_handler( ifstream& in, int argc, char* argv[] )
{
    if( argc < 2 )
    {
        cerr << "A forditando fajl nevet parancssori parameterben kell megadni." << endl;
        exit(1);
    }
    in.open( argv[1] );
    if( !in )
    {
        cerr << "A " << argv[1] << " fajlt nem sikerult megnyitni." << endl;
        exit(1);
    }
}
